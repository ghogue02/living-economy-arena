/**
 * Insider Trading Detection System
 * Prevents unfair advantages from non-public information
 */

const EventEmitter = require('eventemitter3');
const Decimal = require('decimal.js');

class InsiderTradingDetector extends EventEmitter {
    constructor(config = {}) {
        super();
        
        this.config = {
            // Detection thresholds
            suspiciousVolumeMultiplier: config.suspiciousVolumeMultiplier || 5, // 5x normal volume
            unusualProfitThreshold: config.unusualProfitThreshold || 0.15, // 15% profit in short time
            informationLeadTime: config.informationLeadTime || 300000, // 5 minutes before public info
            
            // Pattern analysis windows
            shortTermWindow: config.shortTermWindow || 3600000, // 1 hour
            mediumTermWindow: config.mediumTermWindow || 86400000, // 24 hours
            longTermWindow: config.longTermWindow || 604800000, // 7 days
            
            // Agent behavior analysis
            maxNormalSuccessRate: config.maxNormalSuccessRate || 0.7, // 70% max normal success
            suspiciousTimingThreshold: config.suspiciousTimingThreshold || 0.8, // 80% of trades before events
            
            // Network analysis
            informationPropagationSpeed: config.informationPropagationSpeed || 60000, // 1 minute
            networkClusteringThreshold: config.networkClusteringThreshold || 0.6,
            
            // Enforcement parameters
            penaltySeverityLevels: config.penaltySeverityLevels || {
                minor: { profitClawback: 0.5, tradingRestriction: 3600000 }, // 1 hour
                major: { profitClawback: 1.0, tradingRestriction: 86400000 }, // 24 hours
                severe: { profitClawback: 2.0, tradingRestriction: 604800000 } // 7 days
            },
            
            ...config
        };

        this.state = {
            agentProfiles: new Map(),
            tradingPatterns: new Map(),
            informationEvents: [],
            suspiciousActivities: [],
            networkConnections: new Map(),
            enforcementActions: []
        };

        this.detectionModels = {
            volumeAnomalies: new Map(),
            timingPatterns: new Map(),
            profitAnalysis: new Map(),
            networkAnalysis: new Map()
        };
    }

    // Register agent for insider trading monitoring
    registerAgent(agentId, agentData = {}) {
        const profile = {
            id: agentId,
            registrationDate: Date.now(),
            tradingHistory: [],
            informationAccess: agentData.informationAccess || [],
            networkConnections: new Set(),
            suspicionLevel: 0,
            profitHistory: [],
            volumeHistory: [],
            timingHistory: [],
            penalties: [],
            normalBehaviorBaseline: {
                averageVolume: 0,
                averageProfit: 0,
                successRate: 0,
                typicalTradingTimes: [],
                marketResponseDelay: 0
            }
        };

        this.state.agentProfiles.set(agentId, profile);
        this.detectionModels.volumeAnomalies.set(agentId, []);
        this.detectionModels.timingPatterns.set(agentId, []);
        this.detectionModels.profitAnalysis.set(agentId, []);

        return true;
    }

    // Record trading activity for analysis
    recordTradingActivity(agentId, tradeData) {
        const profile = this.state.agentProfiles.get(agentId);
        if (!profile) return false;

        const trade = {
            timestamp: Date.now(),
            marketId: tradeData.marketId,
            action: tradeData.action, // buy/sell
            quantity: new Decimal(tradeData.quantity),
            price: new Decimal(tradeData.price),
            profit: new Decimal(tradeData.profit || 0),
            volume: new Decimal(tradeData.quantity).mul(tradeData.price),
            preTradePrice: new Decimal(tradeData.preTradePrice || tradeData.price),
            postTradePrice: new Decimal(tradeData.postTradePrice || tradeData.price),
            executionDelay: tradeData.executionDelay || 0,
            informationSources: tradeData.informationSources || []
        };

        profile.tradingHistory.push(trade);
        
        // Keep only recent history
        if (profile.tradingHistory.length > 1000) {
            profile.tradingHistory.shift();
        }

        // Analyze trade for suspicious patterns
        this.analyzeTrade(agentId, trade);
        
        // Update baseline behavior model
        this.updateBehaviorBaseline(agentId);

        return true;
    }

    // Record market information events for correlation analysis
    recordInformationEvent(eventData) {
        const event = {
            timestamp: Date.now(),
            type: eventData.type, // earnings, news, economic_data, etc.
            marketId: eventData.marketId,
            impact: eventData.impact, // price movement caused
            publicReleaseTime: eventData.publicReleaseTime || Date.now(),
            privateAccessors: eventData.privateAccessors || [], // Agents with early access
            informationValue: new Decimal(eventData.informationValue || 0),
            priceMovement: new Decimal(eventData.priceMovement || 0)
        };

        this.state.informationEvents.push(event);
        
        // Analyze trading activity around this event
        this.analyzePreEventTrading(event);
        
        // Keep only recent events
        if (this.state.informationEvents.length > 500) {
            this.state.informationEvents.shift();
        }

        return event;
    }

    // Analyze individual trade for suspicious patterns
    analyzeTrade(agentId, trade) {
        const suspiciousIndicators = [];

        // Volume anomaly detection
        const volumeAnomaly = this.detectVolumeAnomaly(agentId, trade);
        if (volumeAnomaly.isSuspicious) {
            suspiciousIndicators.push(volumeAnomaly);
        }

        // Unusual profit detection
        const profitAnomaly = this.detectProfitAnomaly(agentId, trade);
        if (profitAnomaly.isSuspicious) {
            suspiciousIndicators.push(profitAnomaly);
        }

        // Timing analysis
        const timingAnomaly = this.detectTimingAnomaly(agentId, trade);
        if (timingAnomaly.isSuspicious) {
            suspiciousIndicators.push(timingAnomaly);
        }

        // Information correlation
        const informationCorrelation = this.detectInformationCorrelation(agentId, trade);
        if (informationCorrelation.isSuspicious) {
            suspiciousIndicators.push(informationCorrelation);
        }

        // Update suspicion level
        if (suspiciousIndicators.length > 0) {
            this.updateSuspicionLevel(agentId, suspiciousIndicators);
        }
    }

    detectVolumeAnomaly(agentId, trade) {
        const profile = this.state.agentProfiles.get(agentId);
        const baseline = profile.normalBehaviorBaseline;
        
        const tradeVolume = trade.volume.toNumber();
        const averageVolume = baseline.averageVolume;
        
        if (averageVolume > 0) {
            const volumeMultiplier = tradeVolume / averageVolume;
            
            if (volumeMultiplier > this.config.suspiciousVolumeMultiplier) {
                return {
                    type: 'volume_anomaly',
                    isSuspicious: true,
                    severity: Math.min(1.0, volumeMultiplier / (this.config.suspiciousVolumeMultiplier * 2)),
                    details: {
                        tradeVolume,
                        averageVolume,
                        multiplier: volumeMultiplier
                    }
                };
            }
        }

        return { type: 'volume_anomaly', isSuspicious: false };
    }

    detectProfitAnomaly(agentId, trade) {
        const profit = trade.profit.toNumber();
        const volume = trade.volume.toNumber();
        
        if (volume > 0) {
            const profitPercentage = profit / volume;
            
            if (profitPercentage > this.config.unusualProfitThreshold) {
                // Check if this profit was achieved in a short time frame
                const timeSinceEntry = Date.now() - trade.timestamp;
                
                if (timeSinceEntry < this.config.shortTermWindow) {
                    return {
                        type: 'profit_anomaly',
                        isSuspicious: true,
                        severity: Math.min(1.0, profitPercentage / this.config.unusualProfitThreshold),
                        details: {
                            profitPercentage,
                            profit,
                            volume,
                            timeFrame: timeSinceEntry
                        }
                    };
                }
            }
        }

        return { type: 'profit_anomaly', isSuspicious: false };
    }

    detectTimingAnomaly(agentId, trade) {
        const recentEvents = this.state.informationEvents.filter(event => 
            event.marketId === trade.marketId && 
            Math.abs(event.timestamp - trade.timestamp) < this.config.informationLeadTime
        );

        if (recentEvents.length > 0) {
            // Check if trade occurred before public information release
            const preEventTrades = recentEvents.filter(event => 
                trade.timestamp < event.publicReleaseTime
            );

            if (preEventTrades.length > 0) {
                const timingAdvantage = Math.min(...preEventTrades.map(event => 
                    event.publicReleaseTime - trade.timestamp
                ));

                return {
                    type: 'timing_anomaly',
                    isSuspicious: true,
                    severity: Math.min(1.0, timingAdvantage / this.config.informationLeadTime),
                    details: {
                        timingAdvantage,
                        relatedEvents: preEventTrades.length,
                        tradeTime: trade.timestamp,
                        nextEventTime: Math.min(...preEventTrades.map(e => e.publicReleaseTime))
                    }
                };
            }
        }

        return { type: 'timing_anomaly', isSuspicious: false };
    }

    detectInformationCorrelation(agentId, trade) {
        const profile = this.state.agentProfiles.get(agentId);
        
        // Check if agent has access to non-public information
        const informationAccess = profile.informationAccess;
        
        if (informationAccess.length > 0) {
            // Check if trade aligns with information not yet public
            const relevantInfo = informationAccess.filter(info => 
                info.marketId === trade.marketId &&
                info.timestamp > trade.timestamp - this.config.shortTermWindow &&
                info.publicReleaseTime > trade.timestamp
            );

            if (relevantInfo.length > 0) {
                return {
                    type: 'information_correlation',
                    isSuspicious: true,
                    severity: relevantInfo.length > 1 ? 1.0 : 0.7,
                    details: {
                        informationCount: relevantInfo.length,
                        informationTypes: relevantInfo.map(i => i.type),
                        tradeAlignment: this.calculateTradeAlignment(trade, relevantInfo)
                    }
                };
            }
        }

        return { type: 'information_correlation', isSuspicious: false };
    }

    calculateTradeAlignment(trade, informationList) {
        // Calculate how well the trade aligns with the information
        let alignment = 0;
        
        informationList.forEach(info => {
            if ((trade.action === 'buy' && info.priceMovement > 0) ||
                (trade.action === 'sell' && info.priceMovement < 0)) {
                alignment += Math.abs(info.priceMovement.toNumber());
            }
        });

        return alignment / informationList.length;
    }

    // Analyze trading patterns before information events
    analyzePreEventTrading(event) {
        const preEventWindow = event.publicReleaseTime - this.config.informationLeadTime;
        const postEventWindow = event.publicReleaseTime + this.config.informationLeadTime;

        const suspiciousAgents = [];

        for (const [agentId, profile] of this.state.agentProfiles) {
            const preEventTrades = profile.tradingHistory.filter(trade =>
                trade.marketId === event.marketId &&
                trade.timestamp >= preEventWindow &&
                trade.timestamp <= event.publicReleaseTime
            );

            if (preEventTrades.length > 0) {
                const analysis = this.analyzeAgentPreEventActivity(agentId, preEventTrades, event);
                
                if (analysis.isSuspicious) {
                    suspiciousAgents.push({
                        agentId,
                        analysis,
                        trades: preEventTrades
                    });
                }
            }
        }

        if (suspiciousAgents.length > 0) {
            this.flagSuspiciousActivity({
                type: 'pre_event_trading',
                event,
                suspiciousAgents,
                timestamp: Date.now()
            });
        }
    }

    analyzeAgentPreEventActivity(agentId, preEventTrades, event) {
        const profile = this.state.agentProfiles.get(agentId);
        
        // Calculate metrics
        const totalVolume = preEventTrades.reduce((sum, trade) => 
            sum.plus(trade.volume), new Decimal(0));
        const totalProfit = preEventTrades.reduce((sum, trade) => 
            sum.plus(trade.profit), new Decimal(0));
        
        const averageExecutionDelay = preEventTrades.reduce((sum, trade) => 
            sum + trade.executionDelay, 0) / preEventTrades.length;

        // Compare to normal behavior
        const volumeRatio = totalVolume.div(profile.normalBehaviorBaseline.averageVolume || 1);
        const profitRatio = totalProfit.div(profile.normalBehaviorBaseline.averageProfit || 1);
        
        // Check trade direction alignment with event impact
        const correctDirectionTrades = preEventTrades.filter(trade => {
            return (trade.action === 'buy' && event.priceMovement.gt(0)) ||
                   (trade.action === 'sell' && event.priceMovement.lt(0));
        });
        
        const directionAccuracy = correctDirectionTrades.length / preEventTrades.length;

        // Suspicion scoring
        let suspicionScore = 0;
        
        if (volumeRatio.gt(this.config.suspiciousVolumeMultiplier)) {
            suspicionScore += 0.3;
        }
        
        if (directionAccuracy > this.config.suspiciousTimingThreshold) {
            suspicionScore += 0.4;
        }
        
        if (averageExecutionDelay < profile.normalBehaviorBaseline.marketResponseDelay * 0.5) {
            suspicionScore += 0.3;
        }

        return {
            isSuspicious: suspicionScore > 0.6,
            suspicionScore,
            metrics: {
                volumeRatio: volumeRatio.toNumber(),
                profitRatio: profitRatio.toNumber(),
                directionAccuracy,
                averageExecutionDelay,
                tradeCount: preEventTrades.length
            }
        };
    }

    // Update agent suspicion level
    updateSuspicionLevel(agentId, suspiciousIndicators) {
        const profile = this.state.agentProfiles.get(agentId);
        
        // Calculate total suspicion increase
        const suspicionIncrease = suspiciousIndicators.reduce((sum, indicator) => 
            sum + indicator.severity, 0) / suspiciousIndicators.length;

        profile.suspicionLevel = Math.min(1.0, profile.suspicionLevel + suspicionIncrease * 0.1);

        // Decay suspicion over time
        const timeSinceLastSuspicion = Date.now() - (profile.lastSuspiciousActivity || 0);
        const decayRate = 0.001; // Daily decay
        const decayAmount = (timeSinceLastSuspicion / 86400000) * decayRate;
        profile.suspicionLevel = Math.max(0, profile.suspicionLevel - decayAmount);

        profile.lastSuspiciousActivity = Date.now();

        // Check if enforcement action is needed
        if (profile.suspicionLevel > 0.8) {
            this.triggerEnforcementAction(agentId, 'high_suspicion');
        } else if (profile.suspicionLevel > 0.6) {
            this.triggerEnforcementAction(agentId, 'medium_suspicion');
        }
    }

    // Flag suspicious activity for investigation
    flagSuspiciousActivity(activityData) {
        this.state.suspiciousActivities.push({
            ...activityData,
            id: this.generateActivityId(),
            status: 'flagged',
            investigationRequired: true
        });

        this.emit('suspicious_activity_detected', activityData);

        // Keep only recent activities
        if (this.state.suspiciousActivities.length > 1000) {
            this.state.suspiciousActivities.shift();
        }
    }

    // Trigger enforcement actions
    triggerEnforcementAction(agentId, severity) {
        const profile = this.state.agentProfiles.get(agentId);
        if (!profile) return;

        const penaltyConfig = this.config.penaltySeverityLevels[
            severity === 'high_suspicion' ? 'severe' :
            severity === 'medium_suspicion' ? 'major' : 'minor'
        ];

        const enforcement = {
            id: this.generateEnforcementId(),
            agentId,
            timestamp: Date.now(),
            severity,
            actions: {
                profitClawback: penaltyConfig.profitClawback,
                tradingRestriction: penaltyConfig.tradingRestriction,
                additionalMonitoring: true
            },
            evidence: this.gatherEvidence(agentId),
            status: 'active'
        };

        this.state.enforcementActions.push(enforcement);
        profile.penalties.push(enforcement);

        this.emit('enforcement_action', enforcement);

        return enforcement;
    }

    // Gather evidence for enforcement action
    gatherEvidence(agentId) {
        const profile = this.state.agentProfiles.get(agentId);
        
        return {
            suspicionLevel: profile.suspicionLevel,
            recentSuspiciousActivities: this.state.suspiciousActivities.filter(activity =>
                activity.suspiciousAgents && 
                activity.suspiciousAgents.some(sa => sa.agentId === agentId)
            ).slice(-5),
            tradingPatternAnalysis: this.analyzeTradingPatterns(agentId),
            networkAnalysis: this.analyzeNetworkConnections(agentId),
            profitAnalysis: this.analyzeProfitPatterns(agentId)
        };
    }

    analyzeTradingPatterns(agentId) {
        const profile = this.state.agentProfiles.get(agentId);
        const trades = profile.tradingHistory.slice(-100); // Recent 100 trades

        return {
            averageVolume: trades.reduce((sum, t) => sum + t.volume.toNumber(), 0) / trades.length,
            averageProfit: trades.reduce((sum, t) => sum + t.profit.toNumber(), 0) / trades.length,
            successRate: trades.filter(t => t.profit.gt(0)).length / trades.length,
            marketDistribution: this.calculateMarketDistribution(trades),
            timeDistribution: this.calculateTimeDistribution(trades),
            volumePatterns: this.calculateVolumePatterns(trades)
        };
    }

    calculateMarketDistribution(trades) {
        const distribution = {};
        trades.forEach(trade => {
            distribution[trade.marketId] = (distribution[trade.marketId] || 0) + 1;
        });
        return distribution;
    }

    calculateTimeDistribution(trades) {
        const hourDistribution = new Array(24).fill(0);
        trades.forEach(trade => {
            const hour = new Date(trade.timestamp).getHours();
            hourDistribution[hour]++;
        });
        return hourDistribution;
    }

    calculateVolumePatterns(trades) {
        const volumes = trades.map(t => t.volume.toNumber()).sort((a, b) => a - b);
        return {
            median: volumes[Math.floor(volumes.length / 2)],
            mean: volumes.reduce((sum, v) => sum + v, 0) / volumes.length,
            std: Math.sqrt(volumes.reduce((sum, v) => sum + Math.pow(v - this.mean, 2), 0) / volumes.length),
            max: Math.max(...volumes),
            min: Math.min(...volumes)
        };
    }

    // Update baseline behavior model
    updateBehaviorBaseline(agentId) {
        const profile = this.state.agentProfiles.get(agentId);
        const recentTrades = profile.tradingHistory.slice(-50); // Last 50 trades
        
        if (recentTrades.length > 10) {
            const baseline = profile.normalBehaviorBaseline;
            
            baseline.averageVolume = recentTrades.reduce((sum, trade) => 
                sum + trade.volume.toNumber(), 0) / recentTrades.length;
            
            baseline.averageProfit = recentTrades.reduce((sum, trade) => 
                sum + trade.profit.toNumber(), 0) / recentTrades.length;
            
            baseline.successRate = recentTrades.filter(trade => 
                trade.profit.gt(0)).length / recentTrades.length;
            
            baseline.marketResponseDelay = recentTrades.reduce((sum, trade) => 
                sum + trade.executionDelay, 0) / recentTrades.length;
        }
    }

    // Get insider trading detection report
    getDetectionReport(agentId = null) {
        if (agentId) {
            const profile = this.state.agentProfiles.get(agentId);
            if (!profile) return null;

            return {
                agentId,
                suspicionLevel: profile.suspicionLevel,
                lastActivity: profile.lastSuspiciousActivity,
                totalTrades: profile.tradingHistory.length,
                behaviorBaseline: profile.normalBehaviorBaseline,
                penalties: profile.penalties,
                networkConnections: Array.from(profile.networkConnections),
                riskAssessment: this.calculateRiskAssessment(agentId)
            };
        }

        // Overall system report
        const totalAgents = this.state.agentProfiles.size;
        const suspiciousAgents = Array.from(this.state.agentProfiles.values())
            .filter(profile => profile.suspicionLevel > 0.3).length;
        
        const activePenalties = this.state.enforcementActions
            .filter(action => action.status === 'active').length;

        return {
            totalAgents,
            suspiciousAgents,
            suspiciousActivities: this.state.suspiciousActivities.length,
            activePenalties,
            recentEnforcements: this.state.enforcementActions.slice(-10),
            systemEffectiveness: this.calculateSystemEffectiveness(),
            timestamp: Date.now()
        };
    }

    calculateRiskAssessment(agentId) {
        const profile = this.state.agentProfiles.get(agentId);
        
        const factors = {
            suspicionLevel: profile.suspicionLevel,
            penaltyHistory: profile.penalties.length / 10, // Normalized
            networkRisk: this.calculateNetworkRisk(agentId),
            behaviorDeviations: this.calculateBehaviorDeviations(agentId),
            informationAccess: profile.informationAccess.length / 5 // Normalized
        };

        const overallRisk = Object.values(factors).reduce((sum, factor) => sum + factor, 0) / Object.keys(factors).length;

        return {
            overallRisk: Math.min(1.0, overallRisk),
            factors,
            riskLevel: overallRisk > 0.7 ? 'HIGH' : overallRisk > 0.4 ? 'MEDIUM' : 'LOW'
        };
    }

    calculateNetworkRisk(agentId) {
        // Analyze network connections for collusion patterns
        const profile = this.state.agentProfiles.get(agentId);
        const connections = Array.from(profile.networkConnections);
        
        let networkRisk = 0;
        connections.forEach(connectionId => {
            const connectedProfile = this.state.agentProfiles.get(connectionId);
            if (connectedProfile && connectedProfile.suspicionLevel > 0.5) {
                networkRisk += connectedProfile.suspicionLevel;
            }
        });

        return Math.min(1.0, networkRisk / connections.length);
    }

    calculateBehaviorDeviations(agentId) {
        const profile = this.state.agentProfiles.get(agentId);
        const baseline = profile.normalBehaviorBaseline;
        const recentTrades = profile.tradingHistory.slice(-20);

        if (recentTrades.length === 0) return 0;

        const recentAverageVolume = recentTrades.reduce((sum, trade) => 
            sum + trade.volume.toNumber(), 0) / recentTrades.length;
        
        const volumeDeviation = baseline.averageVolume > 0 ? 
            Math.abs(recentAverageVolume - baseline.averageVolume) / baseline.averageVolume : 0;

        return Math.min(1.0, volumeDeviation);
    }

    calculateSystemEffectiveness() {
        const totalViolations = this.state.suspiciousActivities.length;
        const detectedViolations = this.state.enforcementActions.length;
        
        const detectionRate = totalViolations > 0 ? detectedViolations / totalViolations : 1.0;
        const falsePositiveRate = 0.05; // Estimated 5% false positive rate
        
        return {
            detectionRate,
            falsePositiveRate,
            effectiveness: detectionRate * (1 - falsePositiveRate)
        };
    }

    // Utility functions
    generateActivityId() {
        return `activity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    generateEnforcementId() {
        return `enforcement_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

module.exports = InsiderTradingDetector;