/**
 * Market Manipulation Prevention System
 * Detects and prevents various forms of market abuse including wash trading, 
 * pump and dump schemes, layering, spoofing, and coordinated manipulation
 */

const EventEmitter = require('eventemitter3');
const Decimal = require('decimal.js');

class MarketManipulationPrevention extends EventEmitter {
    constructor(config = {}) {
        super();
        
        this.config = {
            // Wash trading detection
            washTradingTimeWindow: config.washTradingTimeWindow || 3600000, // 1 hour
            washTradingVolumeThreshold: config.washTradingVolumeThreshold || 0.1, // 10% of volume
            maxSelfTradePercentage: config.maxSelfTradePercentage || 0.05, // 5% max self-trading
            
            // Pump and dump detection
            pumpThresholdPercentage: config.pumpThresholdPercentage || 0.2, // 20% price increase
            dumpThresholdPercentage: config.dumpThresholdPercentage || 0.15, // 15% price decrease
            pumpDumpTimeWindow: config.pumpDumpTimeWindow || 86400000, // 24 hours
            volumeSpikeMultiplier: config.volumeSpikeMultiplier || 5, // 5x normal volume
            
            // Layering and spoofing detection
            layeringOrderRatio: config.layeringOrderRatio || 0.8, // 80% of orders cancelled
            spoofingTimeThreshold: config.spoofingTimeThreshold || 30000, // 30 seconds
            spoofingVolumeThreshold: config.spoofingVolumeThreshold || 0.1, // 10% of book depth
            
            // Coordination detection
            coordinationTimeWindow: config.coordinationTimeWindow || 300000, // 5 minutes
            coordinationParticipantThreshold: config.coordinationParticipantThreshold || 3,
            coordinationVolumeThreshold: config.coordinationVolumeThreshold || 0.2, // 20% of volume
            
            // Position limits
            maxMarketSharePerAgent: config.maxMarketSharePerAgent || 0.05, // 5% of market
            maxOrderSizeRatio: config.maxOrderSizeRatio || 0.1, // 10% of average volume
            
            // Enforcement thresholds
            minorViolationThreshold: config.minorViolationThreshold || 0.3,
            majorViolationThreshold: config.majorViolationThreshold || 0.6,
            severeViolationThreshold: config.severeViolationThreshold || 0.8,
            
            ...config
        };

        this.state = {
            markets: new Map(),
            agentActivities: new Map(),
            orderBooks: new Map(),
            detectionResults: [],
            enforcementActions: [],
            networkAnalysis: new Map(),
            coordinationGroups: []
        };

        this.detectionModules = {
            washTrading: new WashTradingDetector(this.config),
            pumpAndDump: new PumpAndDumpDetector(this.config),
            layeringAndSpoofing: new LayeringAndSpoofingDetector(this.config),
            coordination: new CoordinationDetector(this.config)
        };

        this.setupDetectionModules();
    }

    setupDetectionModules() {
        // Set up event listeners for detection modules
        Object.values(this.detectionModules).forEach(module => {
            module.on('violation_detected', (violation) => {
                this.handleViolationDetection(violation);
            });
        });
    }

    // Register market for manipulation monitoring
    registerMarket(marketId, marketData) {
        this.state.markets.set(marketId, {
            id: marketId,
            name: marketData.name,
            normalVolume: new Decimal(marketData.normalVolume || 100000),
            normalPriceRange: {
                min: new Decimal(marketData.basePrice * 0.9),
                max: new Decimal(marketData.basePrice * 1.1)
            },
            currentPrice: new Decimal(marketData.currentPrice || marketData.basePrice),
            priceHistory: [],
            volumeHistory: [],
            participantCount: 0,
            marketShare: new Map(),
            lastUpdate: Date.now()
        });

        this.state.orderBooks.set(marketId, {
            bids: [],
            asks: [],
            recentTrades: [],
            orderHistory: [],
            cancelledOrders: []
        });

        // Initialize detection modules for this market
        Object.values(this.detectionModules).forEach(module => {
            module.registerMarket(marketId, marketData);
        });

        return true;
    }

    // Record trading activity
    recordTradingActivity(agentId, tradeData) {
        const marketId = tradeData.marketId;
        
        // Update agent activity tracking
        if (!this.state.agentActivities.has(agentId)) {
            this.state.agentActivities.set(agentId, {
                id: agentId,
                trades: [],
                orders: [],
                cancelledOrders: [],
                marketPositions: new Map(),
                suspicionScore: 0,
                violationHistory: []
            });
        }

        const agentActivity = this.state.agentActivities.get(agentId);
        agentActivity.trades.push({
            ...tradeData,
            timestamp: Date.now()
        });

        // Update market data
        this.updateMarketData(marketId, tradeData);
        
        // Run detection algorithms
        this.runDetectionAlgorithms(agentId, tradeData);

        return true;
    }

    // Record order activity
    recordOrderActivity(agentId, orderData) {
        const agentActivity = this.state.agentActivities.get(agentId);
        if (!agentActivity) return false;

        const order = {
            ...orderData,
            timestamp: Date.now(),
            agentId
        };

        if (orderData.status === 'placed') {
            agentActivity.orders.push(order);
            this.updateOrderBook(orderData.marketId, order);
        } else if (orderData.status === 'cancelled') {
            agentActivity.cancelledOrders.push(order);
            this.removeFromOrderBook(orderData.marketId, order);
        }

        // Analyze order patterns
        this.analyzeOrderPatterns(agentId, order);

        return true;
    }

    updateMarketData(marketId, tradeData) {
        const market = this.state.markets.get(marketId);
        if (!market) return;

        // Update price history
        market.priceHistory.push({
            timestamp: Date.now(),
            price: tradeData.price,
            volume: tradeData.quantity
        });

        market.currentPrice = new Decimal(tradeData.price);

        // Keep only recent history
        if (market.priceHistory.length > 1000) {
            market.priceHistory.shift();
        }

        // Update volume history
        const currentHour = Math.floor(Date.now() / 3600000);
        const existingVolumeEntry = market.volumeHistory.find(v => v.hour === currentHour);
        
        if (existingVolumeEntry) {
            existingVolumeEntry.volume = existingVolumeEntry.volume.plus(tradeData.quantity);
        } else {
            market.volumeHistory.push({
                hour: currentHour,
                volume: new Decimal(tradeData.quantity)
            });
        }

        // Keep only recent volume history
        if (market.volumeHistory.length > 168) { // 7 days
            market.volumeHistory.shift();
        }

        market.lastUpdate = Date.now();
    }

    updateOrderBook(marketId, order) {
        const orderBook = this.state.orderBooks.get(marketId);
        if (!orderBook) return;

        if (order.side === 'buy') {
            orderBook.bids.push(order);
            orderBook.bids.sort((a, b) => b.price - a.price); // Highest price first
        } else {
            orderBook.asks.push(order);
            orderBook.asks.sort((a, b) => a.price - b.price); // Lowest price first
        }

        orderBook.orderHistory.push(order);
    }

    removeFromOrderBook(marketId, order) {
        const orderBook = this.state.orderBooks.get(marketId);
        if (!orderBook) return;

        if (order.side === 'buy') {
            const index = orderBook.bids.findIndex(b => b.id === order.id);
            if (index !== -1) {
                orderBook.bids.splice(index, 1);
            }
        } else {
            const index = orderBook.asks.findIndex(a => a.id === order.id);
            if (index !== -1) {
                orderBook.asks.splice(index, 1);
            }
        }

        orderBook.cancelledOrders.push({
            ...order,
            cancelledAt: Date.now()
        });
    }

    // Run all detection algorithms
    runDetectionAlgorithms(agentId, tradeData) {
        const detectionPromises = Object.entries(this.detectionModules).map(([name, module]) => {
            return module.analyze(agentId, tradeData).then(result => ({ name, result }));
        });

        Promise.all(detectionPromises).then(results => {
            results.forEach(({ name, result }) => {
                if (result.isViolation) {
                    this.handleViolationDetection({
                        type: name,
                        agentId,
                        tradeData,
                        ...result
                    });
                }
            });
        });
    }

    analyzeOrderPatterns(agentId, order) {
        const agentActivity = this.state.agentActivities.get(agentId);
        const recentOrders = agentActivity.orders.slice(-20);
        const recentCancellations = agentActivity.cancelledOrders.slice(-20);

        // Check for excessive cancellation patterns
        if (recentCancellations.length > 0) {
            const cancellationRate = recentCancellations.length / (recentOrders.length + recentCancellations.length);
            
            if (cancellationRate > this.config.layeringOrderRatio) {
                this.flagSuspiciousActivity(agentId, {
                    type: 'excessive_cancellations',
                    cancellationRate,
                    recentOrders: recentOrders.length,
                    recentCancellations: recentCancellations.length
                });
            }
        }

        // Check for order size manipulation
        const orderSize = new Decimal(order.quantity);
        const market = this.state.markets.get(order.marketId);
        
        if (market) {
            const orderSizeRatio = orderSize.div(market.normalVolume);
            
            if (orderSizeRatio.gt(this.config.maxOrderSizeRatio)) {
                this.flagSuspiciousActivity(agentId, {
                    type: 'oversized_order',
                    orderSize: orderSize.toNumber(),
                    normalVolume: market.normalVolume.toNumber(),
                    ratio: orderSizeRatio.toNumber()
                });
            }
        }
    }

    // Handle violation detection from modules
    handleViolationDetection(violation) {
        this.state.detectionResults.push({
            ...violation,
            timestamp: Date.now(),
            id: this.generateViolationId()
        });

        // Update agent suspicion score
        const agentActivity = this.state.agentActivities.get(violation.agentId);
        if (agentActivity) {
            agentActivity.suspicionScore += violation.severity || 0.5;
            agentActivity.violationHistory.push(violation);
        }

        // Determine enforcement action
        if (violation.severity >= this.config.severeViolationThreshold) {
            this.executeEnforcementAction(violation.agentId, 'severe', violation);
        } else if (violation.severity >= this.config.majorViolationThreshold) {
            this.executeEnforcementAction(violation.agentId, 'major', violation);
        } else if (violation.severity >= this.config.minorViolationThreshold) {
            this.executeEnforcementAction(violation.agentId, 'minor', violation);
        }

        this.emit('manipulation_detected', violation);
    }

    flagSuspiciousActivity(agentId, activityData) {
        const violation = {
            type: 'suspicious_activity',
            agentId,
            details: activityData,
            severity: 0.3,
            timestamp: Date.now()
        };

        this.handleViolationDetection(violation);
    }

    // Execute enforcement actions
    executeEnforcementAction(agentId, severity, violation) {
        const action = {
            id: this.generateEnforcementId(),
            agentId,
            severity,
            violation,
            timestamp: Date.now(),
            penalties: this.calculatePenalties(severity, violation),
            status: 'active'
        };

        this.state.enforcementActions.push(action);

        // Apply penalties
        this.applyPenalties(agentId, action.penalties);

        this.emit('enforcement_action', action);

        return action;
    }

    calculatePenalties(severity, violation) {
        const basePenalties = {
            minor: {
                tradingRestriction: 3600000, // 1 hour
                orderSizeLimit: 0.5, // 50% of normal
                monitoringPeriod: 86400000 // 24 hours
            },
            major: {
                tradingRestriction: 86400000, // 24 hours
                orderSizeLimit: 0.2, // 20% of normal
                monitoringPeriod: 604800000, // 7 days
                profitClawback: 0.5 // 50% of profits from violation period
            },
            severe: {
                tradingRestriction: 604800000, // 7 days
                orderSizeLimit: 0.1, // 10% of normal
                monitoringPeriod: 2592000000, // 30 days
                profitClawback: 1.0, // 100% of profits from violation period
                marketExclusion: [violation.tradeData?.marketId] // Exclude from specific markets
            }
        };

        return basePenalties[severity] || basePenalties.minor;
    }

    applyPenalties(agentId, penalties) {
        // Implementation would integrate with the economic engine
        // to actually enforce these penalties
        
        this.emit('penalties_applied', {
            agentId,
            penalties,
            timestamp: Date.now()
        });
    }

    // Get manipulation prevention report
    getManipulationReport(agentId = null) {
        if (agentId) {
            const agentActivity = this.state.agentActivities.get(agentId);
            if (!agentActivity) return null;

            return {
                agentId,
                suspicionScore: agentActivity.suspicionScore,
                totalTrades: agentActivity.trades.length,
                totalOrders: agentActivity.orders.length,
                cancellationRate: this.calculateCancellationRate(agentId),
                violationHistory: agentActivity.violationHistory,
                marketPositions: Object.fromEntries(agentActivity.marketPositions),
                riskLevel: this.calculateRiskLevel(agentActivity.suspicionScore),
                activeEnforcements: this.getActiveEnforcements(agentId)
            };
        }

        // System-wide report
        const totalViolations = this.state.detectionResults.length;
        const activeEnforcements = this.state.enforcementActions.filter(a => a.status === 'active').length;
        const totalAgents = this.state.agentActivities.size;
        const suspiciousAgents = Array.from(this.state.agentActivities.values())
            .filter(agent => agent.suspicionScore > 0.5).length;

        return {
            totalAgents,
            totalViolations,
            activeEnforcements,
            suspiciousAgents,
            detectionEffectiveness: this.calculateDetectionEffectiveness(),
            recentViolations: this.state.detectionResults.slice(-20),
            marketHealth: this.calculateMarketHealth(),
            timestamp: Date.now()
        };
    }

    calculateCancellationRate(agentId) {
        const agentActivity = this.state.agentActivities.get(agentId);
        const totalOrders = agentActivity.orders.length;
        const cancelledOrders = agentActivity.cancelledOrders.length;
        
        return totalOrders > 0 ? cancelledOrders / totalOrders : 0;
    }

    calculateRiskLevel(suspicionScore) {
        if (suspicionScore > 0.8) return 'HIGH';
        if (suspicionScore > 0.5) return 'MEDIUM';
        if (suspicionScore > 0.2) return 'LOW';
        return 'MINIMAL';
    }

    getActiveEnforcements(agentId) {
        return this.state.enforcementActions.filter(action => 
            action.agentId === agentId && action.status === 'active'
        );
    }

    calculateDetectionEffectiveness() {
        const detectedViolations = this.state.detectionResults.length;
        const enforcementActions = this.state.enforcementActions.length;
        
        const detectionRate = detectedViolations > 0 ? enforcementActions / detectedViolations : 1.0;
        const falsePositiveEstimate = 0.1; // 10% estimated false positive rate
        
        return {
            detectionRate,
            falsePositiveRate: falsePositiveEstimate,
            effectiveness: detectionRate * (1 - falsePositiveEstimate)
        };
    }

    calculateMarketHealth() {
        const marketHealthScores = [];
        
        for (const [marketId, market] of this.state.markets) {
            const recentViolations = this.state.detectionResults.filter(v => 
                v.tradeData?.marketId === marketId &&
                Date.now() - v.timestamp < 86400000 // Last 24 hours
            ).length;
            
            const violationRate = recentViolations / Math.max(1, market.participantCount);
            const healthScore = Math.max(0, 1 - violationRate);
            
            marketHealthScores.push({
                marketId,
                healthScore,
                recentViolations,
                participantCount: market.participantCount
            });
        }

        const overallHealth = marketHealthScores.length > 0 ?
            marketHealthScores.reduce((sum, m) => sum + m.healthScore, 0) / marketHealthScores.length : 1.0;

        return {
            overallHealth,
            marketScores: marketHealthScores,
            status: overallHealth > 0.8 ? 'HEALTHY' : overallHealth > 0.6 ? 'FAIR' : 'POOR'
        };
    }

    // Utility functions
    generateViolationId() {
        return `violation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    generateEnforcementId() {
        return `enforcement_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// Specialized detection modules
class WashTradingDetector extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.tradeNetworks = new Map();
    }

    registerMarket(marketId, marketData) {
        this.tradeNetworks.set(marketId, new Map());
    }

    async analyze(agentId, tradeData) {
        const network = this.tradeNetworks.get(tradeData.marketId);
        if (!network) return { isViolation: false };

        // Look for patterns of trading between the same agents repeatedly
        const counterparty = tradeData.counterparty;
        if (!counterparty) return { isViolation: false };

        const pairKey = [agentId, counterparty].sort().join('_');
        const pairTrades = network.get(pairKey) || [];
        
        pairTrades.push({
            timestamp: Date.now(),
            volume: tradeData.quantity * tradeData.price,
            agentId,
            counterparty
        });

        network.set(pairKey, pairTrades);

        // Analyze recent trading between these agents
        const recentTrades = pairTrades.filter(trade => 
            Date.now() - trade.timestamp < this.config.washTradingTimeWindow
        );

        if (recentTrades.length > 5) { // Multiple trades between same parties
            const totalVolume = recentTrades.reduce((sum, trade) => sum + trade.volume, 0);
            const agentAVolume = recentTrades.filter(t => t.agentId === agentId).reduce((sum, t) => sum + t.volume, 0);
            const agentBVolume = totalVolume - agentAVolume;
            
            // Check for balanced back-and-forth trading (wash trading pattern)
            const volumeBalance = Math.abs(agentAVolume - agentBVolume) / totalVolume;
            
            if (volumeBalance < 0.1) { // Very balanced trading suggests wash trading
                return {
                    isViolation: true,
                    type: 'wash_trading',
                    severity: 1 - volumeBalance, // More balanced = higher severity
                    details: {
                        tradeCount: recentTrades.length,
                        volumeBalance,
                        totalVolume,
                        counterparty
                    }
                };
            }
        }

        return { isViolation: false };
    }
}

class PumpAndDumpDetector extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.priceMovements = new Map();
        this.volumeSpikes = new Map();
    }

    registerMarket(marketId, marketData) {
        this.priceMovements.set(marketId, []);
        this.volumeSpikes.set(marketId, []);
    }

    async analyze(agentId, tradeData) {
        const marketId = tradeData.marketId;
        const priceHistory = this.priceMovements.get(marketId) || [];
        
        priceHistory.push({
            timestamp: Date.now(),
            price: tradeData.price,
            volume: tradeData.quantity,
            agentId
        });

        // Keep only recent history
        const recentHistory = priceHistory.filter(p => 
            Date.now() - p.timestamp < this.config.pumpDumpTimeWindow
        );
        this.priceMovements.set(marketId, recentHistory);

        if (recentHistory.length < 10) return { isViolation: false };

        // Analyze for pump and dump patterns
        const sortedByTime = recentHistory.sort((a, b) => a.timestamp - b.timestamp);
        const startPrice = sortedByTime[0].price;
        const currentPrice = sortedByTime[sortedByTime.length - 1].price;
        const maxPrice = Math.max(...sortedByTime.map(p => p.price));
        
        const pumpPercentage = (maxPrice - startPrice) / startPrice;
        const dumpPercentage = (maxPrice - currentPrice) / maxPrice;
        
        // Check for pump and dump pattern
        if (pumpPercentage > this.config.pumpThresholdPercentage && 
            dumpPercentage > this.config.dumpThresholdPercentage) {
            
            // Analyze agent's role in the pump and dump
            const agentTrades = recentHistory.filter(p => p.agentId === agentId);
            const pumpPhaseTrades = agentTrades.filter(t => t.timestamp < sortedByTime.find(p => p.price === maxPrice).timestamp);
            const dumpPhaseTrades = agentTrades.filter(t => t.timestamp >= sortedByTime.find(p => p.price === maxPrice).timestamp);
            
            const pumpVolume = pumpPhaseTrades.reduce((sum, t) => sum + t.volume, 0);
            const dumpVolume = dumpPhaseTrades.reduce((sum, t) => sum + t.volume, 0);
            
            if (pumpVolume > 0 && dumpVolume > 0) {
                return {
                    isViolation: true,
                    type: 'pump_and_dump',
                    severity: Math.min(1.0, (pumpPercentage + dumpPercentage) / 0.5),
                    details: {
                        pumpPercentage,
                        dumpPercentage,
                        pumpVolume,
                        dumpVolume,
                        timeWindow: this.config.pumpDumpTimeWindow
                    }
                };
            }
        }

        return { isViolation: false };
    }
}

class LayeringAndSpoofingDetector extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.orderPatterns = new Map();
    }

    registerMarket(marketId, marketData) {
        this.orderPatterns.set(marketId, new Map());
    }

    async analyze(agentId, orderData) {
        const marketId = orderData.marketId;
        const agentOrders = this.orderPatterns.get(marketId)?.get(agentId) || [];
        
        agentOrders.push({
            timestamp: Date.now(),
            ...orderData
        });

        // Keep only recent orders
        const recentOrders = agentOrders.filter(o => 
            Date.now() - o.timestamp < this.config.spoofingTimeThreshold
        );

        this.orderPatterns.get(marketId).set(agentId, recentOrders);

        // Analyze for layering (multiple orders at different price levels)
        const activePriceLevels = new Set(recentOrders.filter(o => o.status === 'active').map(o => o.price));
        
        if (activePriceLevels.size >= 5) { // Multiple price levels
            const cancelledCount = recentOrders.filter(o => o.status === 'cancelled').length;
            const totalCount = recentOrders.length;
            const cancellationRate = cancelledCount / totalCount;
            
            if (cancellationRate > this.config.layeringOrderRatio) {
                return {
                    isViolation: true,
                    type: 'layering',
                    severity: cancellationRate,
                    details: {
                        priceLevels: activePriceLevels.size,
                        cancellationRate,
                        totalOrders: totalCount,
                        cancelledOrders: cancelledCount
                    }
                };
            }
        }

        return { isViolation: false };
    }
}

class CoordinationDetector extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.coordinationGroups = new Map();
    }

    registerMarket(marketId, marketData) {
        this.coordinationGroups.set(marketId, []);
    }

    async analyze(agentId, tradeData) {
        // Look for coordinated trading patterns
        const marketId = tradeData.marketId;
        const timeWindow = this.config.coordinationTimeWindow;
        const now = Date.now();
        
        // Find other agents trading in the same time window
        const recentTrades = this.coordinationGroups.get(marketId) || [];
        const coordinatedTrades = recentTrades.filter(trade => 
            Math.abs(trade.timestamp - now) < timeWindow &&
            trade.action === tradeData.action // Same direction (buy/sell)
        );

        coordinatedTrades.push({
            agentId,
            timestamp: now,
            action: tradeData.action,
            volume: tradeData.quantity * tradeData.price
        });

        // Update coordination tracking
        this.coordinationGroups.set(marketId, coordinatedTrades);

        // Check if coordination threshold is met
        const uniqueAgents = new Set(coordinatedTrades.map(t => t.agentId));
        const totalVolume = coordinatedTrades.reduce((sum, t) => sum + t.volume, 0);
        
        if (uniqueAgents.size >= this.config.coordinationParticipantThreshold) {
            return {
                isViolation: true,
                type: 'coordinated_manipulation',
                severity: Math.min(1.0, uniqueAgents.size / 10), // Scale with participant count
                details: {
                    participantCount: uniqueAgents.size,
                    totalVolume,
                    timeWindow,
                    participants: Array.from(uniqueAgents)
                }
            };
        }

        return { isViolation: false };
    }
}

module.exports = MarketManipulationPrevention;