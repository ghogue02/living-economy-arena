/**\n * Persistent World State Manager - Main Entry Point\n * 24/7 autonomous market evolution and comprehensive state persistence\n */\n\nconst PersistenceOrchestrator = require('./integration/persistence-orchestrator');\nconst PersistentStateManager = require('./core/state-manager');\nconst TimeAccelerationEngine = require('./time-acceleration/catch-up-engine');\nconst EventRecordingSystem = require('./events/event-recorder');\nconst MarketSnapshotEngine = require('./snapshots/snapshot-engine');\nconst GlobalStateSynchronization = require('./synchronization/global-sync');\nconst FailoverManager = require('./failover/failover-manager');\n\nclass PersistentWorldStateManager {\n    constructor(config = {}) {\n        this.config = {\n            nodeId: config.nodeId || `persistence-${Date.now()}`,\n            region: config.region || 'us-east-1',\n            role: config.role || 'primary',\n            autonomous: config.autonomous !== false,\n            integration: {\n                orchestrated: config.orchestrated !== false,\n                standalone: config.standalone === true\n            },\n            ...config\n        };\n        \n        this.orchestrator = null;\n        this.isInitialized = false;\n        \n        // Standalone components (if not using orchestrator)\n        this.components = {\n            stateManager: null,\n            timeAcceleration: null,\n            eventRecorder: null,\n            snapshotEngine: null,\n            globalSync: null,\n            failoverManager: null\n        };\n    }\n    \n    async initialize() {\n        try {\n            console.log('Initializing Persistent World State Manager...');\n            console.log(`Configuration: Node ${this.config.nodeId} in ${this.config.region}`);\n            console.log(`Mode: ${this.config.integration.orchestrated ? 'Orchestrated' : 'Standalone'}`);\n            \n            if (this.config.integration.orchestrated) {\n                await this.initializeOrchestrated();\n            } else {\n                await this.initializeStandalone();\n            }\n            \n            this.isInitialized = true;\n            console.log('Persistent World State Manager initialized successfully');\n            \n            return {\n                success: true,\n                mode: this.config.integration.orchestrated ? 'orchestrated' : 'standalone',\n                nodeId: this.config.nodeId,\n                region: this.config.region,\n                autonomous: this.config.autonomous\n            };\n            \n        } catch (error) {\n            console.error('Failed to initialize Persistent World State Manager:', error);\n            throw error;\n        }\n    }\n    \n    async initializeOrchestrated() {\n        console.log('Initializing in orchestrated mode...');\n        \n        this.orchestrator = new PersistenceOrchestrator(this.config);\n        \n        return new Promise((resolve, reject) => {\n            this.orchestrator.once('ready', () => {\n                console.log('Orchestrated persistence system ready');\n                resolve();\n            });\n            \n            this.orchestrator.once('error', (error) => {\n                reject(error);\n            });\n        });\n    }\n    \n    async initializeStandalone() {\n        console.log('Initializing in standalone mode...');\n        \n        // Initialize components individually\n        this.components.stateManager = new PersistentStateManager({\n            ...this.config,\n            nodeId: `${this.config.nodeId}-state`\n        });\n        \n        this.components.timeAcceleration = new TimeAccelerationEngine({\n            ...this.config,\n            nodeId: `${this.config.nodeId}-time`\n        });\n        \n        this.components.eventRecorder = new EventRecordingSystem({\n            ...this.config,\n            nodeId: `${this.config.nodeId}-events`\n        });\n        \n        this.components.snapshotEngine = new MarketSnapshotEngine({\n            ...this.config,\n            nodeId: `${this.config.nodeId}-snapshots`\n        });\n        \n        this.components.globalSync = new GlobalStateSynchronization({\n            ...this.config,\n            nodeId: `${this.config.nodeId}-sync`\n        });\n        \n        this.components.failoverManager = new FailoverManager({\n            ...this.config,\n            nodeId: `${this.config.nodeId}-failover`\n        });\n        \n        // Wait for all components to initialize\n        const readyPromises = Object.values(this.components)\n            .filter(component => component)\n            .map(component => new Promise((resolve, reject) => {\n                if (component.isInitialized) {\n                    resolve();\n                } else {\n                    component.once('ready', resolve);\n                    component.once('error', reject);\n                }\n            }));\n        \n        await Promise.all(readyPromises);\n        console.log('All standalone components initialized');\n    }\n    \n    // Public API methods\n    async recordEvent(event, options = {}) {\n        if (this.orchestrator) {\n            return this.orchestrator.components.eventRecorder.recordEvent(event, options);\n        } else if (this.components.eventRecorder) {\n            return this.components.eventRecorder.recordEvent(event, options);\n        }\n        throw new Error('Event recorder not available');\n    }\n    \n    async updateState(entityId, updates, options = {}) {\n        if (this.orchestrator) {\n            return this.orchestrator.components.stateManager.updateState(entityId, updates, options);\n        } else if (this.components.stateManager) {\n            return this.components.stateManager.updateState(entityId, updates, options);\n        }\n        throw new Error('State manager not available');\n    }\n    \n    async takeSnapshot(entityId = 'global', options = {}) {\n        if (this.orchestrator) {\n            return this.orchestrator.takeEmergencySnapshot(entityId, options.reason);\n        } else if (this.components.snapshotEngine) {\n            return this.components.snapshotEngine.takeSnapshot(entityId, options);\n        }\n        throw new Error('Snapshot engine not available');\n    }\n    \n    async restoreSnapshot(snapshotId, options = {}) {\n        if (this.orchestrator) {\n            return this.orchestrator.restoreFromSnapshot(snapshotId, options.reason);\n        } else if (this.components.snapshotEngine) {\n            return this.components.snapshotEngine.restoreSnapshot(snapshotId, options);\n        }\n        throw new Error('Snapshot engine not available');\n    }\n    \n    async startTimeAcceleration(targetTime, currentTime = Date.now()) {\n        if (this.orchestrator) {\n            return this.orchestrator.startTimeAcceleration(targetTime);\n        } else if (this.components.timeAcceleration) {\n            return this.components.timeAcceleration.startCatchUp(targetTime, currentTime);\n        }\n        throw new Error('Time acceleration engine not available');\n    }\n    \n    async forceSync(entityId = null) {\n        if (this.orchestrator) {\n            return this.orchestrator.components.globalSync.forceSync(entityId);\n        } else if (this.components.globalSync) {\n            return this.components.globalSync.forceSync(entityId);\n        }\n        throw new Error('Global sync not available');\n    }\n    \n    async performEmergencyBackup() {\n        if (this.orchestrator) {\n            return this.orchestrator.performEmergencyBackup();\n        } else {\n            // Perform manual backup with standalone components\n            const results = {};\n            \n            if (this.components.snapshotEngine) {\n                results.snapshot = await this.components.snapshotEngine.takeSnapshot(\n                    'global',\n                    { reason: 'emergency_backup' }\n                );\n            }\n            \n            if (this.components.eventRecorder) {\n                await this.components.eventRecorder.flushEvents();\n                results.events = 'flushed';\n            }\n            \n            if (this.components.globalSync) {\n                results.sync = await this.components.globalSync.forceSync();\n            }\n            \n            return results;\n        }\n    }\n    \n    getSystemStatus() {\n        if (this.orchestrator) {\n            return this.orchestrator.getSystemStatus();\n        } else {\n            const status = {\n                mode: 'standalone',\n                nodeId: this.config.nodeId,\n                region: this.config.region,\n                autonomous: this.config.autonomous,\n                components: {}\n            };\n            \n            for (const [name, component] of Object.entries(this.components)) {\n                if (component && typeof component.getMetrics === 'function') {\n                    try {\n                        status.components[name] = {\n                            status: 'running',\n                            metrics: component.getMetrics()\n                        };\n                    } catch (error) {\n                        status.components[name] = {\n                            status: 'error',\n                            error: error.message\n                        };\n                    }\n                } else {\n                    status.components[name] = {\n                        status: component ? 'unknown' : 'not_initialized'\n                    };\n                }\n            }\n            \n            return status;\n        }\n    }\n    \n    getMetrics() {\n        if (this.orchestrator) {\n            return this.orchestrator.getMetrics();\n        } else {\n            const metrics = {\n                mode: 'standalone',\n                components: {}\n            };\n            \n            for (const [name, component] of Object.entries(this.components)) {\n                if (component && typeof component.getMetrics === 'function') {\n                    try {\n                        metrics.components[name] = component.getMetrics();\n                    } catch (error) {\n                        metrics.components[name] = { error: error.message };\n                    }\n                }\n            }\n            \n            return metrics;\n        }\n    }\n    \n    // Event access\n    on(event, listener) {\n        if (this.orchestrator) {\n            return this.orchestrator.on(event, listener);\n        } else {\n            // In standalone mode, could set up event aggregation\n            console.warn('Event handling in standalone mode not fully implemented');\n        }\n    }\n    \n    once(event, listener) {\n        if (this.orchestrator) {\n            return this.orchestrator.once(event, listener);\n        } else {\n            console.warn('Event handling in standalone mode not fully implemented');\n        }\n    }\n    \n    emit(event, ...args) {\n        if (this.orchestrator) {\n            return this.orchestrator.emit(event, ...args);\n        } else {\n            console.warn('Event handling in standalone mode not fully implemented');\n        }\n    }\n    \n    async shutdown() {\n        console.log('Shutting down Persistent World State Manager...');\n        \n        if (this.orchestrator) {\n            await this.orchestrator.shutdown();\n        } else {\n            // Shutdown standalone components\n            for (const [name, component] of Object.entries(this.components)) {\n                if (component && typeof component.shutdown === 'function') {\n                    try {\n                        console.log(`Shutting down ${name}...`);\n                        await component.shutdown();\n                    } catch (error) {\n                        console.error(`Failed to shutdown ${name}:`, error);\n                    }\n                }\n            }\n        }\n        \n        this.isInitialized = false;\n        console.log('Persistent World State Manager shutdown complete');\n    }\n}\n\n// Export main class and individual components\nmodule.exports = {\n    PersistentWorldStateManager,\n    PersistenceOrchestrator,\n    PersistentStateManager,\n    TimeAccelerationEngine,\n    EventRecordingSystem,\n    MarketSnapshotEngine,\n    GlobalStateSynchronization,\n    FailoverManager\n};