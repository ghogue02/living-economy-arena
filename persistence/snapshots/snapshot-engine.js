/**
 * Market Snapshot Engine
 * Handles comprehensive state snapshots for historical analysis and rollback protection
 */

const EventEmitter = require('events');
const crypto = require('crypto');

class MarketSnapshotEngine extends EventEmitter {
    constructor(config = {}) {
        super();
        
        this.config = {
            snapshotInterval: config.snapshotInterval || 300000, // 5 minutes
            maxSnapshots: config.maxSnapshots || 1000,
            compressionEnabled: config.compressionEnabled !== false,
            incrementalSnapshots: config.incrementalSnapshots !== false,
            checksumValidation: config.checksumValidation !== false,
            redundancyLevel: config.redundancyLevel || 3,
            archivalEnabled: config.archivalEnabled !== false,
            ...config
        };
        
        // Snapshot storage and management
        this.snapshots = new Map();
        this.snapshotIndex = new Map();
        this.snapshotTimeline = [];
        this.incrementalChains = new Map();
        
        // Rollback protection
        this.rollbackProtection = {
            enabled: true,
            maxRollbackWindow: config.maxRollbackWindow || 86400000, // 24 hours
            verificationRequired: true,
            auditTrail: []
        };
        
        // Compression and archival
        this.compressionStats = {\n            totalSnapshots: 0,\n            compressedSnapshots: 0,\n            averageCompressionRatio: 0,\n            totalSizeBefore: 0,\n            totalSizeAfter: 0\n        };\n        \n        // Performance metrics\n        this.metrics = {\n            snapshotsTaken: 0,\n            snapshotsRestored: 0,\n            rollbacksPerformed: 0,\n            averageSnapshotTime: 0,\n            averageRestoreTime: 0,\n            storageEfficiency: 0,\n            integrityChecks: 0,\n            integrityFailures: 0\n        };\n        \n        this.isInitialized = false;\n        this.snapshotInProgress = false;\n        \n        this.initialize();\n    }\n    \n    async initialize() {\n        try {\n            console.log('Initializing Market Snapshot Engine...');\n            \n            // Set up automatic snapshot scheduling\n            this.setupAutomaticSnapshots();\n            \n            // Set up rollback protection\n            this.setupRollbackProtection();\n            \n            // Set up cleanup and archival\n            this.setupCleanupAndArchival();\n            \n            // Set up integrity monitoring\n            this.setupIntegrityMonitoring();\n            \n            this.isInitialized = true;\n            this.emit('ready');\n            \n            console.log('Market Snapshot Engine initialized');\n            \n        } catch (error) {\n            console.error('Failed to initialize Market Snapshot Engine:', error);\n            this.emit('error', error);\n        }\n    }\n    \n    async takeSnapshot(entityId = 'global', options = {}) {\n        if (this.snapshotInProgress && !options.force) {\n            throw new Error('Snapshot already in progress');\n        }\n        \n        this.snapshotInProgress = true;\n        const startTime = Date.now();\n        \n        try {\n            console.log(`Taking snapshot for entity: ${entityId}`);\n            \n            // Generate snapshot metadata\n            const snapshotId = this.generateSnapshotId(entityId);\n            const timestamp = Date.now();\n            \n            // Gather state data\n            const stateData = await this.gatherStateData(entityId, options);\n            \n            // Create snapshot object\n            const snapshot = {\n                id: snapshotId,\n                entityId,\n                timestamp,\n                version: this.getNextVersion(entityId),\n                type: options.incremental ? 'incremental' : 'full',\n                data: stateData,\n                metadata: {\n                    size: this.calculateDataSize(stateData),\n                    checksum: '',\n                    compression: null,\n                    dependencies: options.dependencies || [],\n                    tags: options.tags || [],\n                    reason: options.reason || 'scheduled',\n                    nodeId: options.nodeId || 'unknown'\n                },\n                integrity: {\n                    verified: false,\n                    verificationTime: null,\n                    signatures: []\n                }\n            };\n            \n            // Calculate checksum\n            snapshot.metadata.checksum = this.calculateSnapshotChecksum(snapshot);\n            \n            // Compress if enabled\n            if (this.config.compressionEnabled) {\n                await this.compressSnapshot(snapshot);\n            }\n            \n            // Handle incremental snapshots\n            if (options.incremental) {\n                await this.processIncrementalSnapshot(snapshot, entityId);\n            }\n            \n            // Store snapshot\n            await this.storeSnapshot(snapshot);\n            \n            // Update indexes\n            await this.updateSnapshotIndexes(snapshot);\n            \n            // Verify integrity\n            if (this.config.checksumValidation) {\n                await this.verifySnapshotIntegrity(snapshot);\n            }\n            \n            // Add to rollback protection\n            this.addToRollbackProtection(snapshot);\n            \n            // Update metrics\n            const snapshotTime = Date.now() - startTime;\n            this.updateSnapshotMetrics(snapshotTime);\n            \n            this.emit('snapshot_taken', {\n                snapshotId,\n                entityId,\n                size: snapshot.metadata.size,\n                time: snapshotTime\n            });\n            \n            console.log(`Snapshot ${snapshotId} completed in ${snapshotTime}ms`);\n            \n            return {\n                success: true,\n                snapshotId,\n                entityId,\n                timestamp,\n                size: snapshot.metadata.size,\n                type: snapshot.type,\n                duration: snapshotTime\n            };\n            \n        } catch (error) {\n            console.error(`Snapshot failed for ${entityId}:`, error);\n            this.emit('snapshot_failed', { entityId, error });\n            throw error;\n        } finally {\n            this.snapshotInProgress = false;\n        }\n    }\n    \n    async restoreSnapshot(snapshotId, options = {}) {\n        const startTime = Date.now();\n        \n        try {\n            console.log(`Restoring snapshot: ${snapshotId}`);\n            \n            // Load snapshot\n            const snapshot = await this.loadSnapshot(snapshotId);\n            if (!snapshot) {\n                throw new Error(`Snapshot not found: ${snapshotId}`);\n            }\n            \n            // Verify integrity before restore\n            if (options.verify !== false) {\n                await this.verifySnapshotIntegrity(snapshot);\n            }\n            \n            // Check rollback protection\n            if (this.rollbackProtection.enabled && options.bypassProtection !== true) {\n                await this.checkRollbackProtection(snapshot);\n            }\n            \n            // Decompress if needed\n            let stateData = snapshot.data;\n            if (snapshot.metadata.compression) {\n                stateData = await this.decompressSnapshot(snapshot);\n            }\n            \n            // Handle incremental restore\n            if (snapshot.type === 'incremental') {\n                stateData = await this.reconstructFromIncremental(snapshot);\n            }\n            \n            // Apply state restoration\n            await this.applyStateRestoration(snapshot.entityId, stateData, options);\n            \n            // Log rollback in audit trail\n            this.logRollback(snapshot, options);\n            \n            // Update metrics\n            const restoreTime = Date.now() - startTime;\n            this.updateRestoreMetrics(restoreTime);\n            \n            this.emit('snapshot_restored', {\n                snapshotId,\n                entityId: snapshot.entityId,\n                timestamp: snapshot.timestamp,\n                duration: restoreTime\n            });\n            \n            console.log(`Snapshot ${snapshotId} restored in ${restoreTime}ms`);\n            \n            return {\n                success: true,\n                snapshotId,\n                entityId: snapshot.entityId,\n                timestamp: snapshot.timestamp,\n                restoredAt: Date.now(),\n                duration: restoreTime\n            };\n            \n        } catch (error) {\n            console.error(`Snapshot restore failed for ${snapshotId}:`, error);\n            this.emit('restore_failed', { snapshotId, error });\n            throw error;\n        }\n    }\n    \n    generateSnapshotId(entityId) {\n        const timestamp = Date.now();\n        const random = crypto.randomBytes(8).toString('hex');\n        return `snapshot_${entityId}_${timestamp}_${random}`;\n    }\n    \n    getNextVersion(entityId) {\n        const latestSnapshot = this.getLatestSnapshot(entityId);\n        return latestSnapshot ? latestSnapshot.version + 1 : 1;\n    }\n    \n    async gatherStateData(entityId, options) {\n        // This would integrate with the state management system\n        // For now, we'll simulate gathering comprehensive state data\n        \n        const stateData = {\n            entityId,\n            timestamp: Date.now(),\n            markets: await this.gatherMarketData(entityId),\n            agents: await this.gatherAgentData(entityId),\n            orders: await this.gatherOrderData(entityId),\n            transactions: await this.gatherTransactionData(entityId),\n            economics: await this.gatherEconomicData(entityId),\n            system: await this.gatherSystemData(entityId)\n        };\n        \n        // Add incremental data if this is an incremental snapshot\n        if (options.incremental) {\n            const lastSnapshot = this.getLatestSnapshot(entityId);\n            if (lastSnapshot) {\n                stateData.incrementalFrom = lastSnapshot.id;\n                stateData.changes = await this.calculateStateChanges(lastSnapshot, stateData);\n            }\n        }\n        \n        return stateData;\n    }\n    \n    async gatherMarketData(entityId) {\n        // Gather comprehensive market state\n        return {\n            prices: new Map(), // Current market prices\n            volumes: new Map(), // Trading volumes\n            orderBooks: new Map(), // Order book states\n            indices: new Map(), // Market indices\n            volatility: new Map(), // Volatility measures\n            trends: new Map() // Market trends\n        };\n    }\n    \n    async gatherAgentData(entityId) {\n        // Gather agent states\n        return {\n            activeAgents: new Map(), // Active agent states\n            portfolios: new Map(), // Agent portfolios\n            strategies: new Map(), // Trading strategies\n            performance: new Map(), // Performance metrics\n            relationships: new Map() // Agent relationships\n        };\n    }\n    \n    async gatherOrderData(entityId) {\n        // Gather order book and pending orders\n        return {\n            pendingOrders: new Map(), // All pending orders\n            orderHistory: [], // Recent order history\n            matchingEngine: {}, // Matching engine state\n            liquidityPools: new Map() // Liquidity pool states\n        };\n    }\n    \n    async gatherTransactionData(entityId) {\n        // Gather transaction history and state\n        return {\n            recentTransactions: [], // Recent transactions\n            transactionIndex: new Map(), // Transaction indexing\n            settlements: new Map(), // Settlement states\n            clearingState: {} // Clearing system state\n        };\n    }\n    \n    async gatherEconomicData(entityId) {\n        // Gather economic indicators and state\n        return {\n            inflation: {}, // Inflation data\n            interestRates: {}, // Interest rate data\n            moneySupply: {}, // Money supply metrics\n            economicIndicators: new Map(), // Various indicators\n            policyState: {} // Economic policy state\n        };\n    }\n    \n    async gatherSystemData(entityId) {\n        // Gather system-level state\n        return {\n            configuration: {}, // System configuration\n            performance: {}, // Performance metrics\n            connections: {}, // Connection states\n            resources: {}, // Resource utilization\n            security: {} // Security state\n        };\n    }\n    \n    calculateDataSize(data) {\n        return JSON.stringify(data).length;\n    }\n    \n    calculateSnapshotChecksum(snapshot) {\n        const checksumData = {\n            id: snapshot.id,\n            entityId: snapshot.entityId,\n            timestamp: snapshot.timestamp,\n            data: snapshot.data\n        };\n        \n        return crypto.createHash('sha256')\n            .update(JSON.stringify(checksumData))\n            .digest('hex');\n    }\n    \n    async compressSnapshot(snapshot) {\n        const zlib = require('zlib');\n        const originalSize = snapshot.metadata.size;\n        \n        try {\n            const compressed = await new Promise((resolve, reject) => {\n                zlib.gzip(JSON.stringify(snapshot.data), (error, result) => {\n                    if (error) reject(error);\n                    else resolve(result.toString('base64'));\n                });\n            });\n            \n            const compressedSize = compressed.length;\n            const compressionRatio = (1 - compressedSize / originalSize) * 100;\n            \n            snapshot.data = compressed;\n            snapshot.metadata.compression = {\n                algorithm: 'gzip',\n                originalSize,\n                compressedSize,\n                ratio: compressionRatio\n            };\n            \n            // Update compression statistics\n            this.updateCompressionStats(originalSize, compressedSize);\n            \n            console.log(`Snapshot compressed: ${compressionRatio.toFixed(2)}% reduction`);\n            \n        } catch (error) {\n            console.error('Snapshot compression failed:', error);\n            // Continue without compression\n        }\n    }\n    \n    async decompressSnapshot(snapshot) {\n        const zlib = require('zlib');\n        \n        if (!snapshot.metadata.compression) {\n            return snapshot.data;\n        }\n        \n        try {\n            const buffer = Buffer.from(snapshot.data, 'base64');\n            \n            const decompressed = await new Promise((resolve, reject) => {\n                zlib.gunzip(buffer, (error, result) => {\n                    if (error) reject(error);\n                    else resolve(JSON.parse(result.toString()));\n                });\n            });\n            \n            return decompressed;\n            \n        } catch (error) {\n            console.error('Snapshot decompression failed:', error);\n            throw error;\n        }\n    }\n    \n    async processIncrementalSnapshot(snapshot, entityId) {\n        // Link to previous snapshot in chain\n        const previousSnapshot = this.getLatestSnapshot(entityId);\n        if (previousSnapshot) {\n            snapshot.metadata.previousSnapshot = previousSnapshot.id;\n            \n            // Add to incremental chain\n            if (!this.incrementalChains.has(entityId)) {\n                this.incrementalChains.set(entityId, []);\n            }\n            this.incrementalChains.get(entityId).push(snapshot.id);\n        }\n    }\n    \n    async calculateStateChanges(previousSnapshot, currentState) {\n        // Calculate differences between states for incremental snapshots\n        const changes = {\n            added: {},\n            modified: {},\n            deleted: {}\n        };\n        \n        // This would implement detailed state comparison\n        // For now, we'll return a placeholder\n        return changes;\n    }\n    \n    async reconstructFromIncremental(snapshot) {\n        // Reconstruct full state from incremental chain\n        const chain = this.getIncrementalChain(snapshot);\n        let reconstructedState = {};\n        \n        // Start with base snapshot and apply incremental changes\n        for (const chainSnapshotId of chain) {\n            const chainSnapshot = await this.loadSnapshot(chainSnapshotId);\n            if (chainSnapshot.type === 'full') {\n                reconstructedState = chainSnapshot.data;\n            } else {\n                reconstructedState = this.applyIncrementalChanges(\n                    reconstructedState, \n                    chainSnapshot.data.changes\n                );\n            }\n        }\n        \n        return reconstructedState;\n    }\n    \n    getIncrementalChain(snapshot) {\n        // Get the chain of snapshots needed to reconstruct the state\n        const chain = [];\n        let currentSnapshot = snapshot;\n        \n        while (currentSnapshot) {\n            chain.unshift(currentSnapshot.id);\n            \n            if (currentSnapshot.type === 'full') {\n                break;\n            }\n            \n            const previousId = currentSnapshot.metadata.previousSnapshot;\n            currentSnapshot = previousId ? this.snapshots.get(previousId) : null;\n        }\n        \n        return chain;\n    }\n    \n    applyIncrementalChanges(baseState, changes) {\n        // Apply incremental changes to base state\n        let newState = { ...baseState };\n        \n        // Apply additions\n        for (const [key, value] of Object.entries(changes.added || {})) {\n            newState[key] = value;\n        }\n        \n        // Apply modifications\n        for (const [key, value] of Object.entries(changes.modified || {})) {\n            newState[key] = value;\n        }\n        \n        // Apply deletions\n        for (const key of Object.keys(changes.deleted || {})) {\n            delete newState[key];\n        }\n        \n        return newState;\n    }\n    \n    async storeSnapshot(snapshot) {\n        // Store snapshot in memory and persistent storage\n        this.snapshots.set(snapshot.id, snapshot);\n        \n        // This would integrate with the persistence layer\n        console.log(`Stored snapshot ${snapshot.id} (${snapshot.metadata.size} bytes)`);\n    }\n    \n    async loadSnapshot(snapshotId) {\n        // Load snapshot from storage\n        return this.snapshots.get(snapshotId);\n    }\n    \n    async updateSnapshotIndexes(snapshot) {\n        // Update various indexes for fast querying\n        \n        // Entity-based index\n        const entityKey = `entity:${snapshot.entityId}`;\n        if (!this.snapshotIndex.has(entityKey)) {\n            this.snapshotIndex.set(entityKey, []);\n        }\n        this.snapshotIndex.get(entityKey).push(snapshot.id);\n        \n        // Time-based index\n        const timeKey = `time:${Math.floor(snapshot.timestamp / 3600000)}`; // Hourly buckets\n        if (!this.snapshotIndex.has(timeKey)) {\n            this.snapshotIndex.set(timeKey, []);\n        }\n        this.snapshotIndex.get(timeKey).push(snapshot.id);\n        \n        // Type-based index\n        const typeKey = `type:${snapshot.type}`;\n        if (!this.snapshotIndex.has(typeKey)) {\n            this.snapshotIndex.set(typeKey, []);\n        }\n        this.snapshotIndex.get(typeKey).push(snapshot.id);\n        \n        // Update timeline\n        this.snapshotTimeline.push({\n            id: snapshot.id,\n            entityId: snapshot.entityId,\n            timestamp: snapshot.timestamp,\n            type: snapshot.type,\n            size: snapshot.metadata.size\n        });\n        \n        // Keep timeline sorted and limited\n        this.snapshotTimeline.sort((a, b) => b.timestamp - a.timestamp);\n        if (this.snapshotTimeline.length > this.config.maxSnapshots) {\n            this.snapshotTimeline = this.snapshotTimeline.slice(0, this.config.maxSnapshots);\n        }\n    }\n    \n    async verifySnapshotIntegrity(snapshot) {\n        try {\n            // Verify checksum\n            const calculatedChecksum = this.calculateSnapshotChecksum(snapshot);\n            if (calculatedChecksum !== snapshot.metadata.checksum) {\n                throw new Error('Checksum verification failed');\n            }\n            \n            // Verify data structure\n            if (typeof snapshot.data !== 'object' && typeof snapshot.data !== 'string') {\n                throw new Error('Invalid snapshot data structure');\n            }\n            \n            // Mark as verified\n            snapshot.integrity.verified = true;\n            snapshot.integrity.verificationTime = Date.now();\n            \n            this.metrics.integrityChecks++;\n            \n            return true;\n            \n        } catch (error) {\n            console.error(`Integrity verification failed for ${snapshot.id}:`, error);\n            snapshot.integrity.verified = false;\n            this.metrics.integrityFailures++;\n            throw error;\n        }\n    }\n    \n    setupRollbackProtection() {\n        this.rollbackProtection.auditTrail = [];\n    }\n    \n    addToRollbackProtection(snapshot) {\n        if (!this.rollbackProtection.enabled) return;\n        \n        this.rollbackProtection.auditTrail.push({\n            snapshotId: snapshot.id,\n            entityId: snapshot.entityId,\n            timestamp: snapshot.timestamp,\n            type: 'snapshot_created',\n            checksum: snapshot.metadata.checksum\n        });\n        \n        // Limit audit trail size\n        if (this.rollbackProtection.auditTrail.length > 10000) {\n            this.rollbackProtection.auditTrail = \n                this.rollbackProtection.auditTrail.slice(-5000);\n        }\n    }\n    \n    async checkRollbackProtection(snapshot) {\n        if (!this.rollbackProtection.enabled) return;\n        \n        const now = Date.now();\n        const rollbackWindow = this.rollbackProtection.maxRollbackWindow;\n        \n        // Check if rollback is within allowed window\n        if (now - snapshot.timestamp > rollbackWindow) {\n            throw new Error(`Rollback outside allowed window: ${rollbackWindow}ms`);\n        }\n        \n        // Verify snapshot is in audit trail\n        const auditEntry = this.rollbackProtection.auditTrail.find(\n            entry => entry.snapshotId === snapshot.id\n        );\n        \n        if (!auditEntry) {\n            throw new Error('Snapshot not found in audit trail');\n        }\n        \n        // Verify checksums match\n        if (auditEntry.checksum !== snapshot.metadata.checksum) {\n            throw new Error('Snapshot checksum mismatch in audit trail');\n        }\n    }\n    \n    logRollback(snapshot, options) {\n        this.rollbackProtection.auditTrail.push({\n            snapshotId: snapshot.id,\n            entityId: snapshot.entityId,\n            timestamp: Date.now(),\n            type: 'rollback_performed',\n            reason: options.reason || 'manual',\n            user: options.user || 'system'\n        });\n        \n        this.metrics.rollbacksPerformed++;\n    }\n    \n    async applyStateRestoration(entityId, stateData, options) {\n        // This would integrate with the main state management system\n        console.log(`Applying state restoration for ${entityId}`);\n        \n        // Simulate state restoration\n        await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    getLatestSnapshot(entityId) {\n        const entitySnapshots = this.snapshotIndex.get(`entity:${entityId}`) || [];\n        if (entitySnapshots.length === 0) return null;\n        \n        const latestId = entitySnapshots[entitySnapshots.length - 1];\n        return this.snapshots.get(latestId);\n    }\n    \n    updateSnapshotMetrics(snapshotTime) {\n        this.metrics.snapshotsTaken++;\n        this.metrics.averageSnapshotTime = \n            (this.metrics.averageSnapshotTime * 0.9) + (snapshotTime * 0.1);\n    }\n    \n    updateRestoreMetrics(restoreTime) {\n        this.metrics.snapshotsRestored++;\n        this.metrics.averageRestoreTime = \n            (this.metrics.averageRestoreTime * 0.9) + (restoreTime * 0.1);\n    }\n    \n    updateCompressionStats(originalSize, compressedSize) {\n        this.compressionStats.totalSnapshots++;\n        this.compressionStats.compressedSnapshots++;\n        this.compressionStats.totalSizeBefore += originalSize;\n        this.compressionStats.totalSizeAfter += compressedSize;\n        \n        this.compressionStats.averageCompressionRatio = \n            (1 - this.compressionStats.totalSizeAfter / this.compressionStats.totalSizeBefore) * 100;\n    }\n    \n    setupAutomaticSnapshots() {\n        setInterval(async () => {\n            try {\n                // Take automatic snapshots for all entities\n                await this.takeSnapshot('global', { reason: 'automatic' });\n            } catch (error) {\n                console.error('Automatic snapshot failed:', error);\n            }\n        }, this.config.snapshotInterval);\n    }\n    \n    setupCleanupAndArchival() {\n        // Clean up old snapshots\n        setInterval(() => {\n            this.cleanupOldSnapshots();\n        }, 3600000); // Every hour\n        \n        // Archive snapshots\n        if (this.config.archivalEnabled) {\n            setInterval(() => {\n                this.archiveOldSnapshots();\n            }, 86400000); // Daily\n        }\n    }\n    \n    setupIntegrityMonitoring() {\n        // Periodic integrity checks\n        setInterval(async () => {\n            await this.performIntegrityChecks();\n        }, 1800000); // Every 30 minutes\n    }\n    \n    cleanupOldSnapshots() {\n        if (this.snapshots.size <= this.config.maxSnapshots) return;\n        \n        // Get snapshots sorted by age\n        const sortedSnapshots = Array.from(this.snapshots.values())\n            .sort((a, b) => a.timestamp - b.timestamp);\n        \n        // Remove oldest snapshots\n        const toRemove = sortedSnapshots.slice(0, sortedSnapshots.length - this.config.maxSnapshots);\n        \n        for (const snapshot of toRemove) {\n            this.snapshots.delete(snapshot.id);\n            console.log(`Cleaned up old snapshot: ${snapshot.id}`);\n        }\n    }\n    \n    archiveOldSnapshots() {\n        // Archive snapshots older than a certain threshold\n        const archiveThreshold = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days\n        \n        for (const [id, snapshot] of this.snapshots) {\n            if (snapshot.timestamp < archiveThreshold) {\n                // Archive snapshot (would integrate with archival system)\n                console.log(`Archiving snapshot: ${id}`);\n            }\n        }\n    }\n    \n    async performIntegrityChecks() {\n        // Random integrity checks on existing snapshots\n        const snapshotIds = Array.from(this.snapshots.keys());\n        const sampleSize = Math.min(10, snapshotIds.length);\n        \n        for (let i = 0; i < sampleSize; i++) {\n            const randomIndex = Math.floor(Math.random() * snapshotIds.length);\n            const snapshotId = snapshotIds[randomIndex];\n            const snapshot = this.snapshots.get(snapshotId);\n            \n            try {\n                await this.verifySnapshotIntegrity(snapshot);\n            } catch (error) {\n                console.error(`Integrity check failed for ${snapshotId}:`, error);\n                this.emit('integrity_failure', { snapshotId, error });\n            }\n        }\n    }\n    \n    // Query methods\n    async querySnapshots(criteria) {\n        const results = [];\n        \n        if (criteria.entityId) {\n            const entitySnapshots = this.snapshotIndex.get(`entity:${criteria.entityId}`) || [];\n            results.push(...entitySnapshots);\n        }\n        \n        if (criteria.timeRange) {\n            const { start, end } = criteria.timeRange;\n            const filteredTimeline = this.snapshotTimeline.filter(\n                snapshot => snapshot.timestamp >= start && snapshot.timestamp <= end\n            );\n            results.push(...filteredTimeline.map(s => s.id));\n        }\n        \n        if (criteria.type) {\n            const typeSnapshots = this.snapshotIndex.get(`type:${criteria.type}`) || [];\n            results.push(...typeSnapshots);\n        }\n        \n        // Remove duplicates\n        return [...new Set(results)];\n    }\n    \n    getSnapshotStats() {\n        return {\n            totalSnapshots: this.snapshots.size,\n            snapshotsByEntity: this.getSnapshotsByEntity(),\n            compressionStats: this.compressionStats,\n            rollbackProtection: {\n                enabled: this.rollbackProtection.enabled,\n                auditTrailSize: this.rollbackProtection.auditTrail.length\n            },\n            timelineSize: this.snapshotTimeline.length,\n            indexSize: this.snapshotIndex.size\n        };\n    }\n    \n    getSnapshotsByEntity() {\n        const byEntity = {};\n        \n        for (const [key, snapshots] of this.snapshotIndex) {\n            if (key.startsWith('entity:')) {\n                const entityId = key.replace('entity:', '');\n                byEntity[entityId] = snapshots.length;\n            }\n        }\n        \n        return byEntity;\n    }\n    \n    getMetrics() {\n        return {\n            ...this.metrics,\n            snapshots: this.getSnapshotStats(),\n            performance: {\n                snapshotInProgress: this.snapshotInProgress,\n                memoryUsage: process.memoryUsage(),\n                uptime: process.uptime()\n            }\n        };\n    }\n    \n    async shutdown() {\n        console.log('Shutting down Market Snapshot Engine...');\n        \n        // Take final snapshots if needed\n        if (this.snapshots.size > 0) {\n            try {\n                await this.takeSnapshot('global', { reason: 'shutdown' });\n            } catch (error) {\n                console.error('Final snapshot failed:', error);\n            }\n        }\n        \n        // Clear data structures\n        this.snapshots.clear();\n        this.snapshotIndex.clear();\n        this.snapshotTimeline = [];\n        this.incrementalChains.clear();\n        \n        console.log('Market Snapshot Engine shutdown complete');\n    }\n}\n\nmodule.exports = MarketSnapshotEngine;